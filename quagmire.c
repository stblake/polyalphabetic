//
// Quagmire I - IV ciphers
//

#include "polyalphabetic.h"

/*
   Quagmire Ciphers: The General Case (Quagmire IV) and Specializations

   The Quagmire ciphers (I-IV) are a family of polyalphabetic substitution 
   ciphers that use a Vigenère-like sliding tableau generated from two or three
   keywords. The most general form is Quagmire IV.

   ## Quagmire IV: The General Cipher
   
   Quagmire IV is defined by three independent components, each generated by a 
   unique keyword:
   
   1.  **Plaintext Keyword (PT-KW):** Generates the substitution alphabet 
       for the *Plaintext* letters (the rows of the tableau). This is a 
       keyed alphabet (e.g., "CIPHER" followed by remaining letters A-Z).
   2.  **Ciphertext Keyword (CT-KW):** Generates the substitution alphabet 
       for the *Ciphertext* letters (the columns/sliding rule of the tableau). 
       This is also a keyed alphabet.
   3.  **Cycleword (CW):** Determines the shift/key selection for each position 
       in the message, just like in Vigenère. This is the indicator word.
   
   Encryption (E) and Decryption (D) involve finding the intersection between 
   the PT-KW row and the CT-KW/CW column, based on the Vigenère formula:
   
   $$E: C = (P + K) \pmod{26}$$
   $$D: P = (C - K) \pmod{26}$$
   
   Where P, C, and K are positions (0-25) in their respective keyword alphabets.

   ## Quagmire Specializations (I, II, III)

   Quagmire I, II, and III are simplified versions where one or more of the 
   keywords (PT-KW and CT-KW) are fixed to a simple **Straight Alphabet (A-Z)**, 
   equivalent to using a single-letter keyword.
      
   ### 1. Quagmire I
   
   **Specialization**: The Ciphertext Keyword (CT-KW) is fixed to a straight A-Z alphabet.
   
   * **Plaintext Keyword**: Scrambled (keyed by a word).
   * **Ciphertext Keyword**: Straight A-Z.
   * **Cycleword**: Scrambled (keyed by a word).
   
   ### 2. Quagmire II
   
   **Specialization**: The Plaintext Keyword (PT-KW) is fixed to a straight A-Z alphabet.
   
   * **Plaintext Keyword**: Straight A-Z.
   * **Ciphertext Keyword**: Scrambled (keyed by a word).
   * **Cycleword**: Scrambled (keyed by a word).
   
   ### 3. Quagmire III
   
   **Specialization**: Both the Plaintext Keyword (PT-KW) and Ciphertext Keyword (CT-KW) 
   are generated by the *same* scrambling keyword.
   
   * **Plaintext Keyword**: Scrambled (keyed by a word).
   * **Ciphertext Keyword**: *Identical* to PT-KW.
   * **Cycleword**: Scrambled (keyed by a word).
   
   **Note**: The Vigenère cipher (Type 0) is a further specialization where *both* the PT-KW and CT-KW are fixed to a straight A-Z alphabet.
*/

void quagmire_decrypt(int decrypted[], int cipher_indices[], int cipher_len, 
    int plaintext_keyword_indices[], int ciphertext_keyword_indices[], 
    int cycleword_indices[], int cycleword_len, bool variant) {
    
    int i, j, posn_keyword, posn_cycleword, indx, ct_indx, cw_indx; 

    for (i = 0; i < cipher_len; i++) {
        // Find position of ciphertext char in ciphertext key. 
        for (j = 0; j < ALPHABET_SIZE; j++) {
            ct_indx = ciphertext_keyword_indices[j];
            if (cipher_indices[i] == ct_indx) {
                posn_keyword = j; 
                break ;
            }
        }
        // Find the position of cycleword char in keyword. 
        for (j = 0; j < ALPHABET_SIZE; j++) {
            cw_indx = cycleword_indices[i%cycleword_len];
            if (cw_indx == ciphertext_keyword_indices[j]) {
                posn_cycleword = j; 
                break ;
            }
        }

        if (variant) {
            indx = (posn_keyword + posn_cycleword)%ALPHABET_SIZE;
        } else {
            indx = (posn_keyword - posn_cycleword)%ALPHABET_SIZE;
        }

        if (indx < 0) indx += ALPHABET_SIZE;
        decrypted[i] = plaintext_keyword_indices[indx];
    }
}



void quagmire_encrypt(int encrypted[], int plaintext_indices[], int cipher_len, 
    int plaintext_keyword_indices[], int ciphertext_keyword_indices[], 
    int cycleword_indices[], int cycleword_len, bool variant) {
    
    int i, j, posn_keyword, posn_cycleword, indx, pt_indx, cw_indx;

    for (i = 0; i < cipher_len; i++) {
        for (j = 0; j < ALPHABET_SIZE; j++) {
            pt_indx = plaintext_indices[i];
            if (pt_indx == plaintext_keyword_indices[j]) {
                posn_keyword = j; 
                break ;
            }
        }
        for (j = 0; j < ALPHABET_SIZE; j++) {
            cw_indx = cycleword_indices[i%cycleword_len];
            if (cw_indx == ciphertext_keyword_indices[j]) {
                posn_cycleword = j; 
                break ;
            }
        }
        if (variant) {
            indx = (posn_keyword - posn_cycleword)%ALPHABET_SIZE;
        } else {
            indx = (posn_keyword + posn_cycleword)%ALPHABET_SIZE;
        }
        if (indx < 0) indx += ALPHABET_SIZE;
        encrypted[i] = ciphertext_keyword_indices[indx];
    }
}
